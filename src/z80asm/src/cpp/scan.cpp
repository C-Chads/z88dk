/* Generated by re2c 2.2 */
//-----------------------------------------------------------------------------
// z80asm
// scanner
// Copyright (C) Paulo Custodio, 2011-2023
// License: The Artistic License 2.0, http://www.perlfoundation.org/artistic_license_2_0
//-----------------------------------------------------------------------------

#include "args.h"
#include "if.h"
#include "scan.h"
#include "utils.h"
#include <unordered_map>
#include <cassert>
#include <cmath>
using namespace std;

//-----------------------------------------------------------------------------



#define YYMAXFILL 4

#define FILL_SIZE (8*1024)

//-----------------------------------------------------------------------------

static int a2i(const char* start, const char* end, int base) {
    return static_cast<int>(strtol(string(start, end).c_str(), NULL, base));
}

static double a2f(const char* start, const char* end) {
    return atof(string(start, end).c_str());
}

static string str_swap_x_y(string str) {
    for (auto& c : str) {
        switch (c) {
        case 'x': c = 'y'; break;
        case 'X': c = 'Y'; break;
        case 'y': c = 'x'; break;
        case 'Y': c = 'X'; break;
        default:;
        }
    }
    return str;
}

//-----------------------------------------------------------------------------

static int keyword_flags[] = {
#define X(id, text, flags)		flags,
#include "keyword.def"
};

Keyword keyword_lookup(const string& text) {
    static unordered_map<string, Keyword> keywords = {
#define X(id, text, flags)      { text, Keyword::id },
#include "keyword.def"
    };

    auto it = keywords.find(str_tolower(text));
    if (it == keywords.end())
        return Keyword::None;
    else
        return it->second;
}

bool keyword_is_reg_8(Keyword keyword) {
    return keyword_flags[static_cast<int>(keyword)] & KW_REG_8;
}

bool keyword_is_reg_ix_iy(Keyword keyword) {
    return keyword_flags[static_cast<int>(keyword)] & KW_REG_IX_IY;
}

bool keyword_is_z80_ld_bit(Keyword keyword) {
    return keyword_flags[static_cast<int>(keyword)] & KW_Z80_LD_BIT;
}

//-----------------------------------------------------------------------------

Token::Token(TType type, bool blank_before, int ivalue)
    : m_type(type), m_blank_before(blank_before), m_ivalue(ivalue), m_keyword(Keyword::None) {
}

Token::Token(TType type, bool blank_before, double fvalue)
    : m_type(type), m_blank_before(blank_before), m_fvalue(fvalue), m_keyword(Keyword::None) {
}

Token::Token(TType type, bool blank_before, const string& svalue)
    : m_type(type), m_blank_before(blank_before), m_svalue(svalue) {
    m_keyword = keyword_lookup(svalue);
}

string Token::to_string() const {
    static string tokens[] = {
#define X(id, text)     text,
#include "scan.def"
    };

    switch (m_type) {
    case TType::Ident:
        return m_svalue;
    case TType::Integer:
        return std::to_string(m_ivalue);
    case TType::Floating:
        return std::to_string(m_fvalue);
    case TType::String:
        return string_bytes(m_svalue);
    default:
        return tokens[static_cast<int>(m_type)];
    }
}

string Token::to_string(const vector<Token>& tokens) {
    string out = "";
    for (auto& token : tokens) {
        out = concat(out, token.to_string());
    }
    return out;
}

string Token::string_bytes(const string& text) {
    string out = "\"";
    for (auto c : text) {
        switch (c) {
        case '\a': out += "\\a"; break;
        case '\b': out += "\\b"; break;
        case '\f': out += "\\f"; break;
        case '\n': out += "\\n"; break;
        case '\r': out += "\\r"; break;
        case '\t': out += "\\t"; break;
        case '\v': out += "\\v"; break;
        case '\\': out += "\\\\"; break;
        case '"': out += "\\\""; break;
        default:
            if (c >= 0x20 && c < 0x7f)
                out.push_back(c);
            else if ((c & 0xff) < 8)
                out += "\\" + std::to_string(c);			// \o
            else {
                std::ostringstream ss;
                ss << "\\x"
                    << std::setfill('0') << std::setw(2)
                    << std::hex << static_cast<unsigned int>(c & 0xff) << std::dec;
                out += ss.str();
            }
        }
    }
    out += "\"";
    return out;
}

string Token::concat(const string& s1, const string& s2) {
    if (s1.empty() || s2.empty())
        return s1 + s2;
    else if (str_ends_with(s1, "##"))   // cpp-style concatenation
        return s1.substr(0, s1.length() - 2) + s2;
    else if (is_space(s1.back()) || is_space(s2.front()))
        return s1 + s2;
    else if (is_ident(s1.back()) && is_ident(s2.front()))
        return s1 + " " + s2;
    else if (s1.back() == '$' && is_xdigit(s2.front()))
        return s1 + " " + s2;
    else if ((s1.back() == '%' || s1.back() == '@') &&
        (is_digit(s2.front()) || s2.front() == '"'))
        return s1 + " " + s2;
    else if ((s1.back() == '&' && s2.front() == '&') ||
        (s1.back() == '|' && s2.front() == '|') ||
        (s1.back() == '^' && s2.front() == '^') ||
        (s1.back() == '*' && s2.front() == '*') ||
        (s1.back() == '<' && (s2.front() == '=' || s2.front() == '<' || s2.front() == '>')) ||
        (s1.back() == '>' && (s2.front() == '=' || s2.front() == '>')) ||
        (s1.back() == '=' && s2.front() == '=') ||
        (s1.back() == '!' && s2.front() == '=') ||
        (s1.back() == '#' && s2.front() == '#'))
        return s1 + " " + s2;
    else
        return s1 + s2;
}

//-----------------------------------------------------------------------------

ScannedLine::ScannedLine(const string& text, const vector<Token>& tokens)
    : m_text(text), m_pos(0) {
    std::copy(tokens.begin(), tokens.end(), std::back_inserter(m_tokens));
}

void ScannedLine::append(const ScannedLine& other) {
    m_text = Token::concat(m_text, other.text());
    std::copy(other.tokens().begin(), other.tokens().end(), std::back_inserter(m_tokens));
}

void ScannedLine::append(const vector<Token>& tokens) {
    ScannedLine other{ Token::to_string(tokens), tokens };
    append(other);
}

void ScannedLine::clear() {
    m_text.clear();
    m_tokens.clear();
    m_pos = 0;
}

Token& ScannedLine::peek(int offset) {
    static Token end{ TType::End, false };
    size_t index = m_pos + offset;
    if (index >= m_tokens.size())
        return end;
    else
        return m_tokens[index];
}

void ScannedLine::next(int n) {
    m_pos += n;
    if (m_pos > m_tokens.size())
        m_pos = m_tokens.size();
}

vector<Token> ScannedLine::peek_tokens(int offset) {
    vector<Token> out;
    size_t index = m_pos + offset;
    for (size_t i = index; i < m_tokens.size(); i++)
        out.push_back(m_tokens[i]);
    return out;
}

//-----------------------------------------------------------------------------

FileScanner::FileScanner() {
    line_start = line_end = p = p0 = marker = limit = m_buffer.c_str();
}

bool FileScanner::open(const string& filename) {
    m_got_eof = true;
    m_buffer.clear();
    line_start = line_end = p = p0 = marker = limit = m_buffer.c_str();

    if (!fs::is_regular_file(fs::path(filename))) {
        g_errors.error(ErrCode::FileNotFound, filename);
        return false;
    }
    else {
        m_ifs.open(filename, ios::binary);
        if (!m_ifs.is_open()) {
            g_errors.error(ErrCode::FileOpen, filename);
            perror(filename.c_str());
            return false;
        }
        else {
            m_filename = filename;
            m_location = Location(filename);
            m_got_eof = false;
            fill();
            return true;
        }
    }
}

void FileScanner::scan_text(Location location, const string& text) {
    if (m_ifs.is_open())
        m_ifs.close();
    m_filename = location.filename();
    m_location = location;
    m_buffer = text;
    line_start = line_end = p = p0 = marker = m_buffer.c_str();
    limit = m_buffer.c_str() + m_buffer.size();
    m_got_error = false;
    m_got_eof = true;
}

bool FileScanner::get_text_line(ScannedLine& line) {
    line.clear();
    if (peek_text_line(line)) {
        line_start = p0 = marker = p = line_end;
        return true;
    }
    else
        return false;
}

bool FileScanner::peek_text_line(ScannedLine& line) {
    p = p0 = marker = line_end = line_start;

    while (true) {
        
		{
			char yych;
yyFillLabel0:
			yych = *p;
			switch (yych) {
			case 0x00:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel0;
					goto yy9;
				}
				goto yy2;
			case '\n':	goto yy6;
			case '\r':	goto yy8;
			default:	goto yy4;
			}
yy2:
			++p;
			{ p--; goto end; }
yy4:
			++p;
			{ continue; }
yy6:
			++p;
yy7:
			{ m_location.inc_line(); goto end; }
yy8:
			++p;
yyFillLabel1:
			yych = *p;
			switch (yych) {
			case '\n':	goto yy6;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel1;
				}
				goto yy7;
			}
yy9:
			{ goto end; }
		}

    }

end:
    if (p > line_start) {
        line_end = p;
        p = p0 = marker = line_start;
        string text = string(line_start, line_end);
        line.set_text(text);
        notify_new_line(text);
        return true;
    }
    else {
        return false;
    }
}

bool FileScanner::get_token_line(ScannedLine& line) {
    line.clear();
    string str, error;
    int quote = 0;
    bool raw_strings = g_args.raw_strings();
    m_got_error = false;
    m_blank_before = false;

    peek_text_line(line);
    p = p0 = marker = line_end = line_start;

main_loop:
    while (true) {
        p0 = p;

#define PUSH_TOKEN1(type)       do { line.tokens().emplace_back(type, m_blank_before); \
                                     m_blank_before = false; } while (0)
#define PUSH_TOKEN2(type, arg)  do { line.tokens().emplace_back(type, m_blank_before, arg); \
                                     m_blank_before = false; } while (0)
        
		{
			char yych;
			unsigned int yyaccept = 0;
yyFillLabel2:
			yych = *p;
			switch (yych) {
			case 0x00:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel2;
					goto yy149;
				}
				goto yy12;
			case '\t':
			case '\v':
			case '\f':
			case ' ':	goto yy16;
			case '\n':	goto yy19;
			case '\r':	goto yy21;
			case '!':	goto yy22;
			case '"':	goto yy24;
			case '#':	goto yy26;
			case '$':	goto yy28;
			case '%':	goto yy30;
			case '&':	goto yy32;
			case '\'':	goto yy34;
			case '(':	goto yy36;
			case ')':	goto yy38;
			case '*':	goto yy40;
			case '+':	goto yy42;
			case ',':	goto yy44;
			case '-':	goto yy46;
			case '.':	goto yy48;
			case '/':	goto yy50;
			case '0':	goto yy52;
			case '1':	goto yy54;
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy56;
			case ':':	goto yy58;
			case ';':	goto yy60;
			case '<':	goto yy63;
			case '=':	goto yy65;
			case '>':	goto yy67;
			case '?':	goto yy69;
			case '@':	goto yy71;
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy72;
			case '[':	goto yy75;
			case '\\':	goto yy77;
			case ']':	goto yy79;
			case '^':	goto yy81;
			case '{':	goto yy83;
			case '|':	goto yy85;
			case '}':	goto yy87;
			case '~':	goto yy89;
			default:	goto yy14;
			}
yy12:
			++p;
			{ p--; goto end; }
yy14:
			++p;
yy15:
			{ scan_error(ErrCode::InvalidChar); continue; }
yy16:
			++p;
yyFillLabel3:
			yych = *p;
			switch (yych) {
			case '\t':
			case '\v':
			case '\f':
			case ' ':	goto yy16;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel3;
				}
				goto yy18;
			}
yy18:
			{ m_blank_before = true; continue; }
yy19:
			++p;
yy20:
			{ goto end; }
yy21:
			++p;
yyFillLabel4:
			yych = *p;
			switch (yych) {
			case '\n':	goto yy19;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel4;
				}
				goto yy20;
			}
yy22:
			++p;
yyFillLabel5:
			yych = *p;
			switch (yych) {
			case '=':	goto yy91;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel5;
				}
				goto yy23;
			}
yy23:
			{ PUSH_TOKEN1(TType::LogNot); continue; }
yy24:
			++p;
			{ quote = 2; goto string_loop; }
yy26:
			++p;
yyFillLabel6:
			yych = *p;
			switch (yych) {
			case '#':	goto yy93;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel6;
				}
				goto yy27;
			}
yy27:
			{ PUSH_TOKEN1(TType::Hash); continue; }
yy28:
			++p;
yyFillLabel7:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':	goto yy95;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel7;
				}
				goto yy29;
			}
yy29:
			{ PUSH_TOKEN1(TType::ASMPC); continue; }
yy30:
			yyaccept = 0;
			marker = ++p;
yyFillLabel8:
			yych = *p;
			switch (yych) {
			case '"':	goto yy98;
			case '0':
			case '1':	goto yy101;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel8;
				}
				goto yy31;
			}
yy31:
			{ PUSH_TOKEN1(TType::Mod); continue; }
yy32:
			++p;
yyFillLabel9:
			yych = *p;
			switch (yych) {
			case '&':	goto yy104;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel9;
				}
				goto yy33;
			}
yy33:
			{ PUSH_TOKEN1(TType::BinAnd); continue; }
yy34:
			++p;
			{ quote = 1; goto string_loop; }
yy36:
			++p;
			{ PUSH_TOKEN1(TType::LParen); continue; }
yy38:
			++p;
			{ PUSH_TOKEN1(TType::RParen); continue; }
yy40:
			++p;
yyFillLabel10:
			yych = *p;
			switch (yych) {
			case '*':	goto yy106;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel10;
				}
				goto yy41;
			}
yy41:
			{ PUSH_TOKEN1(TType::Mul); continue; }
yy42:
			++p;
			{ PUSH_TOKEN1(TType::Plus); continue; }
yy44:
			++p;
			{ PUSH_TOKEN1(TType::Comma); continue; }
yy46:
			++p;
			{ PUSH_TOKEN1(TType::Minus); continue; }
yy48:
			++p;
yyFillLabel11:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy108;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel11;
				}
				goto yy49;
			}
yy49:
			{ PUSH_TOKEN1(TType::Dot); continue; }
yy50:
			++p;
			{ PUSH_TOKEN1(TType::Div); continue; }
yy52:
			yyaccept = 1;
			marker = ++p;
yyFillLabel12:
			yych = *p;
			switch (yych) {
			case 0x00:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel12;
				}
				goto yy53;
			case 'B':
			case 'b':	goto yy113;
			case 'X':
			case 'x':	goto yy118;
			default:	goto yy55;
			}
yy53:
			{ PUSH_TOKEN2(TType::Integer, a2i(p0, p, 10)); continue; }
yy54:
			yyaccept = 1;
			marker = ++p;
yyFillLabel13:
			yych = *p;
yy55:
			switch (yych) {
			case '.':	goto yy108;
			case '0':
			case '1':	goto yy54;
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy56;
			case 'A':
			case 'C':
			case 'E':
			case 'F':
			case 'a':
			case 'c':
			case 'e':
			case 'f':	goto yy111;
			case 'B':
			case 'b':	goto yy119;
			case 'D':
			case 'd':	goto yy115;
			case 'H':
			case 'h':	goto yy116;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel13;
				}
				goto yy53;
			}
yy56:
			yyaccept = 1;
			marker = ++p;
yyFillLabel14:
			yych = *p;
			switch (yych) {
			case '.':	goto yy108;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy56;
			case 'A':
			case 'B':
			case 'C':
			case 'E':
			case 'F':
			case 'a':
			case 'b':
			case 'c':
			case 'e':
			case 'f':	goto yy111;
			case 'D':
			case 'd':	goto yy115;
			case 'H':
			case 'h':	goto yy116;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel14;
				}
				goto yy53;
			}
yy58:
			++p;
			{ PUSH_TOKEN1(TType::Colon); continue; }
yy60:
			++p;
yyFillLabel15:
			yych = *p;
			switch (yych) {
			case 0x00:
			case '\n':
			case '\r':
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel15;
				}
				goto yy62;
			default:	goto yy60;
			}
yy62:
			{ continue; }
yy63:
			++p;
yyFillLabel16:
			yych = *p;
			switch (yych) {
			case '<':	goto yy120;
			case '=':	goto yy122;
			case '>':	goto yy91;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel16;
				}
				goto yy64;
			}
yy64:
			{ PUSH_TOKEN1(TType::Lt); continue; }
yy65:
			++p;
yyFillLabel17:
			yych = *p;
			switch (yych) {
			case '=':	goto yy124;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel17;
				}
				goto yy66;
			}
yy66:
			{ PUSH_TOKEN1(TType::Eq); continue; }
yy67:
			++p;
yyFillLabel18:
			yych = *p;
			switch (yych) {
			case '=':	goto yy125;
			case '>':	goto yy127;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel18;
				}
				goto yy68;
			}
yy68:
			{ PUSH_TOKEN1(TType::Gt); continue; }
yy69:
			++p;
			{ PUSH_TOKEN1(TType::Quest); continue; }
yy71:
			yyaccept = 2;
			marker = ++p;
yyFillLabel19:
			yych = *p;
			switch (yych) {
			case '"':	goto yy98;
			case '0':
			case '1':	goto yy101;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel19;
				}
				goto yy15;
			}
yy72:
			++p;
yyFillLabel20:
			yych = *p;
			switch (yych) {
			case '\'':	goto yy129;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy72;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel20;
				}
				goto yy74;
			}
yy74:
			{ str = string(p0, p);

                              // to upper
                              if (g_args.ucase()) str = str_toupper(str);

                              // handle af' et all
                              Keyword keyword = keyword_lookup(str);
                              if (str.back() == '\'' && keyword == Keyword::None) { // drop quote
                                str.pop_back();
                                p--;
                                keyword = keyword_lookup(str);
                              }

                              // check for -IXIY
                              if (g_args.swap_ixiy() != IXIY_NO_SWAP) {
                                switch (keyword) {
                                case Keyword::IX: case Keyword::IXH: case Keyword::IXL:
                                case Keyword::IY: case Keyword::IYH: case Keyword::IYL:
                                  str = str_swap_x_y(str);
                                  keyword = keyword_lookup(str);
                                  break;
                                default:;
                                }
                              }

                              // check for .ASSUME
                              if (keyword == Keyword::ASSUME && !line.tokens().empty() &&
                                  line.tokens().back().is(TType::Dot))
                                line.tokens().pop_back();       // remove '.'

                              // need raw strings after INCLUDE, BINARY, INCBIN, LINE, C_LINE
                              switch (keyword) {
                              case Keyword::INCLUDE: case Keyword::BINARY: case Keyword::INCBIN:
                              case Keyword::LINE:    case Keyword::C_LINE:
                                raw_strings = true;
                                break;
                              default:;
                              }

                              // check for ASMPC
                              if (keyword == Keyword::ASMPC)
                                PUSH_TOKEN1(TType::ASMPC);
                              else
                                PUSH_TOKEN2(TType::Ident, str);
                              continue;
                            }
yy75:
			++p;
			{ PUSH_TOKEN1(TType::LSquare); continue; }
yy77:
			++p;
yyFillLabel21:
			yych = *p;
			switch (yych) {
			case '\n':	goto yy130;
			case '\r':	goto yy132;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel21;
				}
				goto yy78;
			}
yy78:
			{ PUSH_TOKEN1(TType::Backslash); continue; }
yy79:
			++p;
			{ PUSH_TOKEN1(TType::RSquare); continue; }
yy81:
			++p;
yyFillLabel22:
			yych = *p;
			switch (yych) {
			case '^':	goto yy133;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel22;
				}
				goto yy82;
			}
yy82:
			{ PUSH_TOKEN1(TType::BinXor); continue; }
yy83:
			++p;
			{ PUSH_TOKEN1(TType::LBrace); continue; }
yy85:
			++p;
yyFillLabel23:
			yych = *p;
			switch (yych) {
			case '|':	goto yy135;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel23;
				}
				goto yy86;
			}
yy86:
			{ PUSH_TOKEN1(TType::BinOr); continue; }
yy87:
			++p;
			{ PUSH_TOKEN1(TType::RBrace); continue; }
yy89:
			++p;
			{ PUSH_TOKEN1(TType::BinNot); continue; }
yy91:
			++p;
			{ PUSH_TOKEN1(TType::Ne); continue; }
yy93:
			++p;
			{ PUSH_TOKEN1(TType::DblHash); continue; }
yy95:
			++p;
yyFillLabel24:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':	goto yy95;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel24;
				}
				goto yy97;
			}
yy97:
			{ PUSH_TOKEN2(TType::Integer, a2i(p0+1, p, 16)); continue; }
yy98:
			++p;
yyFillLabel25:
			yych = *p;
			switch (yych) {
			case '"':	goto yy137;
			case '#':
			case '-':	goto yy98;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel25;
				}
				goto yy100;
			}
yy100:
			p = marker;
			switch (yyaccept) {
			case 0:
				goto yy31;
			case 1:
				goto yy53;
			case 2:
				goto yy15;
			case 3:
				goto yy110;
			case 4:
				goto yy114;
			default:
				goto yy142;
			}
yy101:
			++p;
yyFillLabel26:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':	goto yy101;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel26;
				}
				goto yy103;
			}
yy103:
			{ PUSH_TOKEN2(TType::Integer, a2i(p0+1, p, 2)); continue; }
yy104:
			++p;
			{ PUSH_TOKEN1(TType::LogAnd); continue; }
yy106:
			++p;
			{ PUSH_TOKEN1(TType::Pow); continue; }
yy108:
			yyaccept = 3;
			marker = ++p;
yyFillLabel27:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy108;
			case 'E':
			case 'e':	goto yy139;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel27;
				}
				goto yy110;
			}
yy110:
			{ PUSH_TOKEN2(TType::Floating, a2f(p0, p)); continue; }
yy111:
			++p;
yyFillLabel28:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':	goto yy111;
			case 'H':
			case 'h':	goto yy116;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel28;
				}
				goto yy100;
			}
yy113:
			yyaccept = 4;
			marker = ++p;
yyFillLabel29:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'H':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'h':	goto yy141;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel29;
				}
				goto yy114;
			}
yy114:
			{ PUSH_TOKEN2(TType::Integer, a2i(p0, p, 2)); continue; }
yy115:
			yyaccept = 1;
			marker = ++p;
yyFillLabel30:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':	goto yy111;
			case 'H':
			case 'h':	goto yy116;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel30;
				}
				goto yy53;
			}
yy116:
			++p;
			{ PUSH_TOKEN2(TType::Integer, a2i(p0, p, 16)); continue; }
yy118:
			++p;
yyFillLabel31:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':	goto yy143;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel31;
				}
				goto yy100;
			}
yy119:
			yyaccept = 4;
			marker = ++p;
yyFillLabel32:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':	goto yy111;
			case 'H':
			case 'h':	goto yy116;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel32;
				}
				goto yy114;
			}
yy120:
			++p;
			{ PUSH_TOKEN1(TType::LShift); continue; }
yy122:
			++p;
			{ PUSH_TOKEN1(TType::Le); continue; }
yy124:
			++p;
			goto yy66;
yy125:
			++p;
			{ PUSH_TOKEN1(TType::Ge); continue; }
yy127:
			++p;
			{ PUSH_TOKEN1(TType::RShift); continue; }
yy129:
			++p;
			goto yy74;
yy130:
			++p;
yy131:
			{ line_start = p; peek_text_line(line); continue; }
yy132:
			++p;
yyFillLabel33:
			yych = *p;
			switch (yych) {
			case '\n':	goto yy130;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel33;
				}
				goto yy131;
			}
yy133:
			++p;
			{ PUSH_TOKEN1(TType::LogXor); continue; }
yy135:
			++p;
			{ PUSH_TOKEN1(TType::LogOr); continue; }
yy137:
			++p;
			{
                              int n = 0;
                              for (const char* i = p0+2; i < p-1; i++) {
                                  n *= 2;
                                  if (*i == '#') n++;
                              }
                              PUSH_TOKEN2(TType::Integer, n);
                              continue;
                            }
yy139:
			++p;
yyFillLabel34:
			yych = *p;
			switch (yych) {
			case '+':
			case '-':	goto yy146;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy147;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel34;
				}
				goto yy100;
			}
yy140:
			yyaccept = 5;
			marker = ++p;
yyFillLabel35:
			yych = *p;
yy141:
			switch (yych) {
			case '0':
			case '1':	goto yy140;
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':	goto yy111;
			case 'H':
			case 'h':	goto yy116;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel35;
				}
				goto yy142;
			}
yy142:
			{ PUSH_TOKEN2(TType::Integer, a2i(p0+2, p, 2)); continue; }
yy143:
			++p;
yyFillLabel36:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':	goto yy143;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel36;
				}
				goto yy145;
			}
yy145:
			{ PUSH_TOKEN2(TType::Integer, a2i(p0+2, p, 16)); continue; }
yy146:
			++p;
yyFillLabel37:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy147;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel37;
				}
				goto yy100;
			}
yy147:
			++p;
yyFillLabel38:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy147;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel38;
				}
				goto yy110;
			}
yy149:
			{ goto end; }
		}

    }

string_loop:
    str.clear();
    error.clear();
    while (true) {
        p0 = p;
        
		{
			char yych;
yyFillLabel39:
			yych = *p;
			switch (yych) {
			case 0x00:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel39;
					goto yy190;
				}
				goto yy152;
			case '\n':	goto yy156;
			case '\r':	goto yy158;
			case '"':	goto yy159;
			case '\'':	goto yy161;
			case '\\':	goto yy163;
			default:	goto yy154;
			}
yy152:
			++p;
			{ p--; scan_error(ErrCode::MissingQuote, error); goto end; }
yy154:
			++p;
yy155:
			{ str.push_back(*p0); continue; }
yy156:
			++p;
yy157:
			{ if (raw_strings) {
                                str.append(string(p0, p));
                                error = "started at " + m_location.filename() +
                                        ":" + std::to_string(m_location.line_num());
                                line_start = p; peek_text_line(line);
                                continue;
                              }
                              else {
                                scan_error(ErrCode::MissingQuote, error); goto end;
                              }
                            }
yy158:
			++p;
yyFillLabel40:
			yych = *p;
			switch (yych) {
			case '\n':	goto yy156;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel40;
				}
				goto yy157;
			}
yy159:
			++p;
			{ if (quote == 2) {
                                PUSH_TOKEN2(TType::String, str);
                                goto main_loop;
                              }
                              else {
                                str.push_back(*p0);
                                continue;
                              }
                            }
yy161:
			++p;
			{ if (quote == 1) {
                                if (str.length() != 1) {
                                  scan_error(ErrCode::InvalidCharConst);
                                  goto main_loop;
                                }
                                else {
                                  PUSH_TOKEN2(TType::Integer, str[0]);
                                  goto main_loop;
                                }
                              }
                              else {
                                str.push_back(*p0);
                                continue;
                              }
                            }
yy163:
			++p;
yyFillLabel41:
			yych = *p;
			switch (yych) {
			case '\n':	goto yy155;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':	goto yy166;
			case 'a':	goto yy168;
			case 'b':	goto yy170;
			case 'e':	goto yy172;
			case 'f':	goto yy174;
			case 'n':	goto yy176;
			case 'r':	goto yy178;
			case 't':	goto yy180;
			case 'v':	goto yy182;
			case 'x':	goto yy184;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel41;
					goto yy155;
				}
				goto yy164;
			}
yy164:
			++p;
yy165:
			{ if (raw_strings) {
                                str.push_back(*p0); p--;
                              }
                              else {
                                str.push_back(p0[1]);
                              }
                              continue;
                            }
yy166:
			++p;
yyFillLabel42:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':	goto yy185;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel42;
				}
				goto yy167;
			}
yy167:
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back(a2i(p0+1, p, 8)); } continue; }
yy168:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\a'); } continue; }
yy170:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\b'); } continue; }
yy172:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\x1b'); } continue; }
yy174:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\f'); } continue; }
yy176:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\n'); } continue; }
yy178:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\r'); } continue; }
yy180:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\t'); } continue; }
yy182:
			++p;
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back('\v'); } continue; }
yy184:
			++p;
yyFillLabel43:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':	goto yy186;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel43;
				}
				goto yy165;
			}
yy185:
			++p;
yyFillLabel44:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':	goto yy188;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel44;
				}
				goto yy167;
			}
yy186:
			++p;
yyFillLabel45:
			yych = *p;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':	goto yy189;
			default:
				if (limit <= p) {
					if (yyfill() == 0) goto yyFillLabel45;
				}
				goto yy187;
			}
yy187:
			{ if (raw_strings) { str.push_back(*p0); p = p0+1; }
                              else { str.push_back(a2i(p0+2, p, 16)); } continue; }
yy188:
			++p;
			goto yy167;
yy189:
			++p;
			goto yy187;
yy190:
			{ scan_error(ErrCode::MissingQuote, error); goto end; }
		}

    }

end:
    if (p > line_start) {
        if (m_got_error)
            line.tokens().clear();

        PUSH_TOKEN1(TType::Newline);
        line_start = line_end = p0 = marker = p;
        return true;
    }
    else
        return false;
}

bool FileScanner::fill() {
    if (m_got_eof)
        return false;
    else {
        // save indexes
        size_t line_start_index = line_start - m_buffer.c_str();
        size_t line_end_index = line_end - m_buffer.c_str();
        size_t p_index = p - m_buffer.c_str();
        size_t p0_index = p0 - m_buffer.c_str();
        size_t marker_index = marker - m_buffer.c_str();

        // remove all before line_start
        m_buffer.erase(m_buffer.begin(), m_buffer.begin() + line_start_index);

        // adjust indices
        line_end_index -= line_start_index;
        p_index -= line_start_index;
        p0_index -= line_start_index;
        line_start_index = 0;

        // read from file
        size_t cur_size = m_buffer.size();
        m_buffer.resize(cur_size + FILL_SIZE + YYMAXFILL);      // reserve extra YYMAXFILL for re2c
        m_ifs.read(&m_buffer[cur_size], FILL_SIZE);
        m_buffer.resize(cur_size + m_ifs.gcount());

        // check for end of file
        if (m_ifs.gcount() < FILL_SIZE) {     // got to the end of file
            m_got_eof = true;
            if (!m_buffer.empty() && !is_eol(m_buffer.back()))
                m_buffer.push_back('\n');       // add missing newline
            m_buffer.push_back('\n');           // read a blank line at the end
        }

        // adjust pointers
        line_start = m_buffer.c_str() + line_start_index;
        line_end = m_buffer.c_str() + line_end_index;
        p = m_buffer.c_str() + p_index;
        p0 = m_buffer.c_str() + p0_index;
        marker = m_buffer.c_str() + marker_index;
        limit = m_buffer.c_str() + m_buffer.size();

        return true;
    }
}

void FileScanner::notify_new_line(const string& text_) {
    string text = str_chomp(text_) + "\n";
    m_location.set_source_line(text);
    g_errors.set_location(m_location);
    list_got_source_line(m_location.filename().c_str(), m_location.line_num(),
        m_location.source_line().c_str());
}

void FileScanner::scan_error(ErrCode code, const string& arg) {
    if (!m_got_error)
        g_errors.error(code, arg);
    m_got_error = true;
}
